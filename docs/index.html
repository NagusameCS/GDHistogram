<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDHistogram</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #fafafa;
            --card: #ffffff;
            --text: #1a1a1a;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border: #e5e5e5;
            --accent: #1a1a1a;
            --accent-hover: #333333;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 720px;
            margin: 0 auto;
            padding: 60px 24px;
        }
        
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 24px;
        }
        
        .logo {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 32px;
        }
        
        h1 {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 12px;
            letter-spacing: -0.5px;
        }
        
        h2 {
            font-size: 18px;
            font-weight: 600;
            margin: 32px 0 16px;
            letter-spacing: -0.3px;
        }
        
        p {
            color: var(--text-secondary);
            margin-bottom: 24px;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
            text-decoration: none;
        }
        
        .btn-primary {
            background: var(--accent);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--accent-hover);
        }
        
        .btn-secondary {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--bg);
        }
        
        .btn + .btn {
            margin-left: 12px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            font-size: 15px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--card);
            color: var(--text);
            transition: border-color 0.15s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        input[type="text"]::placeholder {
            color: var(--text-muted);
        }
        
        .input-group {
            margin-bottom: 24px;
        }
        
        .input-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .input-hint {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        
        .hidden { display: none !important; }
        
        .alert {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 24px;
            font-size: 14px;
        }
        
        .alert-error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }
        
        .divider {
            height: 1px;
            background: var(--border);
            margin: 32px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin: 24px 0;
        }
        
        .stat-card {
            text-align: center;
            padding: 20px 12px;
            background: var(--bg);
            border-radius: 8px;
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 600;
            color: var(--text);
            letter-spacing: -0.5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .progress-container {
            margin: 32px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        
        .events-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .events-table th {
            text-align: left;
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }
        
        .events-table td {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
        }
        
        .events-table tr:last-child td {
            border-bottom: none;
        }
        
        .event-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        #histogram {
            width: 100%;
            height: 320px;
            margin: 24px 0;
        }
        
        .setup-section {
            background: var(--bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 24px;
        }
        
        .setup-section h3 {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text);
        }
        
        .setup-section ol {
            margin: 0;
            padding-left: 20px;
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        .setup-section li {
            margin-bottom: 8px;
        }
        
        .setup-section code {
            background: var(--card);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid var(--border);
        }
        
        .actions {
            display: flex;
            gap: 12px;
            margin-top: 32px;
        }
        
        @media (max-width: 600px) {
            .container { padding: 24px 16px; }
            .card { padding: 24px; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            h1 { font-size: 24px; }
            .actions { flex-direction: column; }
            .btn + .btn { margin-left: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Welcome Screen -->
        <div id="screen-welcome" class="card">
            <div class="logo">GDHistogram</div>
            <h1>Analyze Google Docs</h1>
            <p>Detect typing patterns, anomalies, and revision history in any Google Document.</p>
            
            <div class="setup-section">
                <h3>First-time setup</h3>
                <ol>
                    <li>Go to <a href="https://console.cloud.google.com/apis/credentials" target="_blank">Google Cloud Console</a></li>
                    <li>Add <code id="origin-url"></code> to Authorized JavaScript origins</li>
                    <li>Add <code id="redirect-url"></code> to Authorized redirect URIs</li>
                </ol>
            </div>
            
            <div class="input-group">
                <label class="input-label">OAuth Client ID</label>
                <input type="text" id="client-id-input" placeholder="your-client-id.apps.googleusercontent.com">
                <div class="input-hint">Stored locally in your browser only</div>
            </div>
            
            <button class="btn btn-primary" onclick="startAuth()">
                Sign in with Google
            </button>
        </div>
        
        <!-- Document Input Screen -->
        <div id="screen-document" class="card hidden">
            <div class="logo">GDHistogram</div>
            <h1>Enter Document URL</h1>
            <p>Paste the link to the Google Doc you want to analyze.</p>
            
            <div class="input-group">
                <input type="text" id="doc-url" placeholder="https://docs.google.com/document/d/...">
            </div>
            
            <div id="doc-error" class="alert alert-error hidden"></div>
            
            <div class="actions">
                <button class="btn btn-primary" onclick="analyzeDocument()">Analyze</button>
                <button class="btn btn-secondary" onclick="signOut()">Sign out</button>
            </div>
        </div>
        
        <!-- Analyzing Screen -->
        <div id="screen-analyzing" class="card hidden">
            <div class="logo">GDHistogram</div>
            <h1>Analyzing</h1>
            
            <div class="progress-container">
                <div class="progress-text" id="analysis-status">Starting...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>
        
        <!-- Results Screen -->
        <div id="screen-results" class="card hidden">
            <div class="logo">GDHistogram</div>
            <h1>Analysis Complete</h1>
            
            <div class="stats-grid" id="stats-grid"></div>
            
            <div class="divider"></div>
            
            <h2>WPM Distribution</h2>
            <div id="histogram"></div>
            
            <div class="divider"></div>
            
            <h2>Detected Anomalies</h2>
            <table class="events-table">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Time</th>
                        <th>Deviation</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody id="events-body"></tbody>
            </table>
            
            <div class="actions">
                <button class="btn btn-primary" onclick="exportResults()">Export JSON</button>
                <button class="btn btn-secondary" onclick="showScreen('document')">New Analysis</button>
            </div>
        </div>
    </div>

    <script>
        const SCOPES = 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/documents.readonly';
        const REDIRECT_URI = window.location.origin + window.location.pathname;
        
        let accessToken = null;
        let analysisResults = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('origin-url').textContent = window.location.origin;
            document.getElementById('redirect-url').textContent = REDIRECT_URI;
            
            const savedClientId = localStorage.getItem('gdhistogram_client_id');
            const defaultClientId = '646422605911-t7mnbg107rvv7ji9mqc5ajstfmnnggkv.apps.googleusercontent.com';
            document.getElementById('client-id-input').value = savedClientId || defaultClientId;
            
            const hash = window.location.hash;
            if (hash.includes('access_token')) {
                handleAuthCallback(hash);
            }
        });
        
        function showScreen(name) {
            document.querySelectorAll('.card').forEach(el => el.classList.add('hidden'));
            document.getElementById('screen-' + name).classList.remove('hidden');
        }
        
        function startAuth() {
            const clientId = document.getElementById('client-id-input').value.trim();
            if (!clientId) {
                alert('Please enter your OAuth Client ID');
                return;
            }
            
            localStorage.setItem('gdhistogram_client_id', clientId);
            
            const authUrl = 'https://accounts.google.com/o/oauth2/v2/auth?' + new URLSearchParams({
                client_id: clientId,
                redirect_uri: REDIRECT_URI,
                response_type: 'token',
                scope: SCOPES,
                include_granted_scopes: 'true',
                prompt: 'consent'
            });
            
            window.location.href = authUrl;
        }
        
        function handleAuthCallback(hash) {
            const params = new URLSearchParams(hash.substring(1));
            accessToken = params.get('access_token');
            
            if (accessToken) {
                history.replaceState(null, '', window.location.pathname);
                showScreen('document');
            } else {
                const error = params.get('error');
                alert('Authentication failed: ' + (error || 'Unknown error'));
            }
        }
        
        function signOut() {
            accessToken = null;
            showScreen('welcome');
        }
        
        async function analyzeDocument() {
            const docUrl = document.getElementById('doc-url').value.trim();
            const errorDiv = document.getElementById('doc-error');
            errorDiv.classList.add('hidden');
            
            const fileId = extractFileId(docUrl);
            if (!fileId) {
                errorDiv.textContent = 'Please enter a valid Google Docs URL';
                errorDiv.classList.remove('hidden');
                return;
            }
            
            showScreen('analyzing');
            
            try {
                updateProgress('Fetching revisions...', 10);
                const revisions = await fetchRevisions(fileId);
                
                if (revisions.length < 2) {
                    throw new Error('Document needs at least 2 revisions');
                }
                
                updateProgress(`Found ${revisions.length} revisions`, 20);
                const contents = await fetchRevisionContents(fileId, revisions);
                
                updateProgress('Computing metrics...', 60);
                const metrics = computeMetrics(revisions, contents);
                
                updateProgress('Detecting anomalies...', 80);
                const events = detectEvents(metrics);
                
                updateProgress('Done', 100);
                analysisResults = { revisions, metrics, events, fileId };
                
                displayResults();
                showScreen('results');
                
            } catch (error) {
                console.error('Analysis error:', error);
                errorDiv.textContent = error.message;
                errorDiv.classList.remove('hidden');
                showScreen('document');
            }
        }
        
        function extractFileId(url) {
            const patterns = [
                /\/document\/d\/([a-zA-Z0-9_-]+)/,
                /id=([a-zA-Z0-9_-]+)/,
                /^([a-zA-Z0-9_-]{20,})$/
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        }
        
        function updateProgress(status, percent) {
            document.getElementById('analysis-status').textContent = status;
            document.getElementById('progress-fill').style.width = percent + '%';
        }
        
        async function fetchRevisions(fileId) {
            const response = await fetch(
                `https://www.googleapis.com/drive/v3/files/${fileId}/revisions?fields=revisions(id,modifiedTime,lastModifyingUser,size)`,
                { headers: { 'Authorization': 'Bearer ' + accessToken } }
            );
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || 'Failed to fetch revisions');
            }
            
            const data = await response.json();
            return data.revisions || [];
        }
        
        async function fetchRevisionContents(fileId, revisions) {
            const contents = [];
            
            // For Google Docs, we need to export each revision as plain text
            // But the Revisions API doesn't support export for Docs
            // So we'll use revision metadata (size changes) to estimate content changes
            // and fetch the current document content for reference
            
            // First, get current document content
            let currentContent = '';
            try {
                const response = await fetch(
                    `https://www.googleapis.com/drive/v3/files/${fileId}/export?mimeType=text/plain`,
                    { headers: { 'Authorization': 'Bearer ' + accessToken } }
                );
                if (response.ok) {
                    currentContent = await response.text();
                }
            } catch (e) {
                console.log('Could not export current content');
            }
            
            // For revisions, we'll estimate based on size metadata
            // This is a limitation of the Google Drive API for native Google Docs
            for (let i = 0; i < revisions.length; i++) {
                const rev = revisions[i];
                updateProgress(`Processing revision ${i + 1}/${revisions.length}`, 20 + (40 * i / revisions.length));
                
                // Use size as a proxy for content length
                const size = parseInt(rev.size) || 0;
                // Create synthetic content based on size for metrics calculation
                contents.push('x'.repeat(Math.floor(size / 5))); // Rough char estimate
            }
            
            // Store current content for reference
            contents.currentContent = currentContent;
            contents.totalWords = currentContent.split(/\s+/).filter(w => w.length > 0).length;
            
            return contents;
        }
        
        function computeMetrics(revisions, contents) {
            const metrics = [];
            
            for (let i = 1; i < revisions.length; i++) {
                const prevSize = parseInt(revisions[i - 1].size) || 0;
                const currSize = parseInt(revisions[i].size) || 0;
                const prevTime = new Date(revisions[i - 1].modifiedTime);
                const currTime = new Date(revisions[i].modifiedTime);
                
                // Estimate words from size (roughly 5 chars per word average)
                const prevWords = Math.floor(prevSize / 5);
                const currWords = Math.floor(currSize / 5);
                const addedChars = Math.max(0, currSize - prevSize);
                const deletedChars = Math.max(0, prevSize - currSize);
                const addedWords = Math.floor(addedChars / 5);
                const deletedWords = Math.floor(deletedChars / 5);
                
                const timeDiffMinutes = Math.max(0.1, (currTime - prevTime) / 60000);
                const wpm = addedWords / timeDiffMinutes;
                
                // Characters per minute (more accurate than WPM for size-based estimation)
                const cpm = addedChars / timeDiffMinutes;
                
                metrics.push({
                    revision: i,
                    timestamp: currTime,
                    timeDiffMinutes,
                    addedWords,
                    deletedWords,
                    addedChars,
                    deletedChars,
                    wpm: Math.min(wpm, 1000),
                    cpm: Math.min(cpm, 5000),
                    sizeChange: currSize - prevSize,
                    user: revisions[i].lastModifyingUser?.displayName || 'Unknown'
                });
            }
            
            return metrics;
        }
        
        function detectEvents(metrics) {
            const events = [];
            if (metrics.length === 0) return events;
            
            // Calculate statistics for outlier detection
            const cpms = metrics.filter(m => m.cpm > 0).map(m => m.cpm);
            const sizeChanges = metrics.map(m => Math.abs(m.sizeChange));
            
            if (cpms.length === 0) return events;
            
            // Mean and standard deviation for CPM
            const avgCpm = cpms.reduce((a, b) => a + b, 0) / cpms.length;
            const stdCpm = Math.sqrt(cpms.reduce((a, b) => a + Math.pow(b - avgCpm, 2), 0) / cpms.length) || 1;
            
            // Mean and standard deviation for size changes
            const avgSizeChange = sizeChanges.reduce((a, b) => a + b, 0) / sizeChanges.length;
            const stdSizeChange = Math.sqrt(sizeChanges.reduce((a, b) => a + Math.pow(b - avgSizeChange, 2), 0) / sizeChanges.length) || 1;
            
            // Z-score threshold for outliers (1.5 = mild outlier, 2 = moderate, 3 = extreme)
            const zThreshold = 1.5;
            
            for (const m of metrics) {
                const cpmZScore = (m.cpm - avgCpm) / stdCpm;
                const sizeZScore = (Math.abs(m.sizeChange) - avgSizeChange) / stdSizeChange;
                
                // Anomaly: Very high typing speed (likely paste)
                if (cpmZScore > zThreshold && m.cpm > 500) {
                    events.push({
                        type: 'Anomaly',
                        timestamp: m.timestamp,
                        wpm: m.wpm,
                        zScore: cpmZScore.toFixed(1),
                        reason: `Speed ${cpmZScore.toFixed(1)}σ above avg (${m.cpm.toFixed(0)} CPM vs ${avgCpm.toFixed(0)} avg)`
                    });
                }
                
                // Large content change (outlier in size)
                if (sizeZScore > zThreshold && Math.abs(m.sizeChange) > 500) {
                    const changeType = m.sizeChange > 0 ? 'Added' : 'Deleted';
                    events.push({
                        type: changeType,
                        timestamp: m.timestamp,
                        wpm: m.wpm,
                        zScore: sizeZScore.toFixed(1),
                        reason: `${Math.abs(m.sizeChange)} chars (${sizeZScore.toFixed(1)}σ from norm)`
                    });
                }
                
                // Long pause
                if (m.timeDiffMinutes > 60) {
                    events.push({
                        type: 'Pause',
                        timestamp: m.timestamp,
                        wpm: m.wpm,
                        zScore: '-',
                        reason: `${(m.timeDiffMinutes / 60).toFixed(1)} hour gap`
                    });
                }
            }
            
            return events.sort((a, b) => {
                // Sort by z-score (most anomalous first), then by time
                const aZ = parseFloat(a.zScore) || 0;
                const bZ = parseFloat(b.zScore) || 0;
                if (bZ !== aZ) return bZ - aZ;
                return b.timestamp - a.timestamp;
            });
        }
        
        function displayResults() {
            const { metrics, events } = analysisResults;
            
            // Calculate CPM stats for display
            const cpms = metrics.filter(m => m.cpm > 0).map(m => m.cpm);
            const avgCpm = cpms.length > 0 ? cpms.reduce((a, b) => a + b, 0) / cpms.length : 0;
            const totalCharsAdded = metrics.reduce((a, m) => a + m.addedChars, 0);
            
            document.getElementById('stats-grid').innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${metrics.length}</div>
                    <div class="stat-label">Revisions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${(totalCharsAdded / 1000).toFixed(1)}k</div>
                    <div class="stat-label">Chars Added</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgCpm.toFixed(0)}</div>
                    <div class="stat-label">Avg CPM</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${events.length}</div>
                    <div class="stat-label">Anomalies</div>
                </div>
            `;
            
            // Use CPM for histogram (more reliable with size-based estimation)
            const trace = {
                x: cpms,
                type: 'histogram',
                marker: { color: '#1a1a1a' },
                nbinsx: Math.min(25, Math.max(10, Math.floor(cpms.length / 3)))
            };
            
            const layout = {
                xaxis: { title: 'Characters Per Minute', gridcolor: '#e5e5e5' },
                yaxis: { title: 'Frequency', gridcolor: '#e5e5e5' },
                margin: { t: 20, r: 20, b: 50, l: 50 },
                paper_bgcolor: 'transparent',
                plot_bgcolor: 'transparent',
                bargap: 0.1,
                font: { family: '-apple-system, BlinkMacSystemFont, sans-serif', color: '#1a1a1a' }
            };
            
            Plotly.newPlot('histogram', [trace], layout, { responsive: true, displayModeBar: false });
            
            const eventsBody = document.getElementById('events-body');
            if (events.length === 0) {
                eventsBody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#999;">No anomalies detected - all revisions within normal range</td></tr>';
            } else {
                eventsBody.innerHTML = events.slice(0, 20).map(e => `
                    <tr>
                        <td><span class="event-badge">${e.type}</span></td>
                        <td>${e.timestamp.toLocaleDateString()} ${e.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</td>
                        <td>${e.zScore !== '-' ? e.zScore + 'σ' : '-'}</td>
                        <td>${e.reason}</td>
                    </tr>
                `).join('');
            }
        }
        
        function exportResults() {
            const dataStr = JSON.stringify(analysisResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gdhistogram-${analysisResults.fileId}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>